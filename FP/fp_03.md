# 3. Why Functional Programming?

앞에서 설명했다시피 함수형 프로그래밍은 전혀 새로운 것이 아닙니다.
역사에 대해서는 후술하겠지만 이론적 배경인 Lambda Calculus는 1930년대에 나왔고
지금 가장 유명한 함수형 언어인 Haskell조차 1990년에 등장하였습니다.
하지만 지금, 그 어느 때보다도 유례없이 함수형 프로그래밍의 중요성이 부각되고 있는데
그 이유에 대해 알아보도록 합시다.

## 무어의 법칙의 붕괴

> The complexity for minimum component costs has increased at a rate of roughly a factor of two per year ... 
Certainly over the short term this rate can be expected to continue, if not to increase. 
Over the longer term, the rate of increase is a bit more uncertain, 
although there is no reason to believe it will not remain nearly constant for at least 10 years. 
That means by 1975, the number of components per integrated circuit for minimum cost will be 65,000. 
I believe that such a large circuit can be built on a single wafer.[^1]

무어의 법칙이란, 반도체 집적회로의 성능, 즉 컴퓨팅 성능이 24개월마다 2배로 증가한다는 법칙입니다.
오로지 귀납적 추론에 근거하므로 사실 법칙이라고 거창하게 이름 붙일 것은 아닙니다만, 이상하리만치
잘 맞아왔던 법칙입니다. ~~(항간에는 이 법칙을 맞추려 공대생들을 갈아넣는다는 소문이..)~~

하지만 2010년대에 들어와서 무어의 법칙은 50년 동안의 전통을 깨고 종말을 고했습니다.
특히 최근엔 10nm 공정에 들어서면서 여러가지 파열음이 나오며 더더욱 집적도 향상은 기대하기 어려워졌죠.
CPU 회사들은 자체적으로 무어의 법칙을 따르지 않겠다 선언하고 싱글 코어의 성능향상보다는 코어 수를 늘리는 것에
집중하고 있고 그동안 그래픽에나 쓰이던 GPU가 계산계의 신성으로 떠오르는 등 하드웨어 업계는
엄청난 변화의 바람에 휩싸여 있습니다.
그리고 이러한 하드웨어 패러다임의 변화는 당연하게도 프로그래밍 패러다임에 영향을 줍니다.

무어의 법칙은 프로그래머에게 굉장히 훌륭한 법칙이었습니다.
프로그래머는 그저 싱글 코어로 잘 돌아가는 코드를 짜놓으면 24개월마다 하드웨어가 업그레이드 되며
코드 역시 성능이 2배 향상되었습니다. 그야말로 공짜 점심이었죠.
하지만, 정보 및 데이터의 양은 압도적으로 늘어가는데 코어의 쿨럭 향상은 크게 기대할 수 없는 상황이 되었습니다.
이러한 시대에 아직도 싱글코어를 고집하면 자연스럽게 도태될 수 밖에 없습니다.
이제 프로그래머들은 필연적으로 병렬 혹은 병행 프로그래밍의 세계에 뛰어들 수 밖에 없어졌습니다.
그렇게 다시 희망이 보이는 듯 했지만 문제가 하나 생겼습니다.

### Deadlock

![deadlock](image/deadlock.jpg)

데드락은 병렬 프로그래밍을 해본 사람이라면 꼭 한 번쯤은 겪었을 문제입니다.
스레드나 코어가 어떠한 데이터를 다루고 있을 때, 안전하게 작업하기 위하여 다른 스레드나 코어들은 접근할 수 없게
잠금(Lock)을 겁니다. 한 번 락이 걸리면 그것이 풀릴 때까지 다른 스레드나 코어들은 그 데이터에 접근할 수 없게 되는데
문제는 여러 스레드가 동시에 여러 데이터에 락을 걸어버리면 모두 눈치보느라 영원히 락이 풀리지 않는 현상이 생깁니다. 
그것이 바로 데드락입니다. 이는 현대 프로그래밍에서 가장 중요한 문제 중 하나이고 따라서 이미 여러 해답들이 제시되었습니다.
재미있는 것은 프로그래밍 언어에 따라 이 해결 방법이 다른데 이에 대해 간략히 소개하면 다음과 같습니다.

* Python: GIL(Global Interpreter Lock) - 한 번에 하나의 락만 허용되게 하여 데드락이 발생하지 않음
* JS, Java, C#, Go and etc.: Async(비동기) - 직접적인 해답은 아니지만, 나머지 스레드들이 대기하고 있는 것이 아니라 비동기적으로 실행함으로 데드락을 우회.
* Rust: Ownership(소유권) - 값의 대입이 일어날 때, 소유권을 전달함으로서 동일한 자료로의 접근 자체를 제한한다.

이들 방법은 여러모로 다르지만 공통적인 특징은 성능과 편안함 중에 하나만 골라야 된다는 것입니다.
예를 들어 Python의 GIL은 상당히 편하지만 성능은 좋지 않습니다. 반대로 Rust의 소유권 개념은 비용없는 추상화까지 지원하며 압도적인 성능을 보여주지만
진입장벽이 무척 높을 정도로 불편합니다. 이에 대하여 Haskell을 위시한 함수형 언어들은 기묘한 대안을 제시합니다.

* Haskell and FP family: Immutable - 모든 자료가 불변이라 데이터의 변경자체가 존재하지 않으므로 이론적으로 완벽한 병렬의 구현이 가능.


[^1]: Moore, Gordon E. (1965-04-19). "Cramming more components onto integrated circuits". Electronics. Retrieved 2016-07-01.
